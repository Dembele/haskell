---------------------------------------------------------------------------------
-- №10. Определите функцию, осуществляющую удаление указанного количества по-  --
-- следних элементов исходного списка.                                         --
---------------------------------------------------------------------------------
butlast :: Int -> [Int] -> [Int]
butlast 0 x = x
butlast _ [] = []
butlast x y = butlast (x-1) (init y)
---------------------------------------------------------------------------------
---                             Тест-кейсы:                                    --
---------------------------------------------------------------------------------
-- butlast 1 [1,2,3,4]             --           [1,2,3]              --   OK   --
-- butlast 3 [1,2,3,4]             --           [1]                  --   OK   --
-- butlast 4 [1,2,3,4]             --           []                   --   OK   --
-- butlast 0 [1,2,3,4]             --           [1,2,3,4]            --   OK   --
-- butlast 5 []                    --           []                   --   OK   --
---------------------------------------------------------------------------------
--- №11. Определите функцию, осуществляющую разделение исходного списка на два --
--- подсписка. В первый из них должно попасть указанное количество элементов   --
--- с начала списка, во второй — оставшиеся элементы.                          --
---------------------------------------------------------------------------------
sepAtN :: Int -> [a] -> ([a], [a])
sepAtN _ []     = ([], [])
sepAtN 1 (x:xs) = ([x], xs)
sepAtN m (x:xs) = (x:xs', xs'')
  where
    (xs', xs'') = sepAtN (m - 1) xs

---------------------------------------------------------------------------------
---                             Тест-кейсы:                                    --
---------------------------------------------------------------------------------
-- sepAtN 1 [1,2,3,4]              --           ([1],[2,3,4])        --   OK   --
-- sepAtN 3 [1,2,3,4]              --           ([1,2,3],[4])        --   OK   --
-- sepAtN 4 [1,2,3,4]              --           ([1,2,3,4],[])       --   OK   --
-- sepAtN 5 [1,2,3,4]              --           ([1,2,3,4],[])       --   OK   --
-- sepAtN 0 [1,2,3,4]              --           ([],[1,2,3,4])       --   OK   --
-- sepAtN 1 []                     --           ([],[])              --   OK   --
---------------------------------------------------------------------------------
--- №14. Определите функцию, осуществляющую перестановку двух элементов списка --
--- с заданными номерами.                                                      --
---------------------------------------------------------------------------------
swapAt :: Int -> Int -> [Int] -> [Int]
swapAt i j x = if (i>j) then swapAt j i x
  else let elemAtI = x !! i
           elemAtJ = x !! j
           left = take i x
           middle = take (j - i - 1) (drop (i + 1) x)
           right = drop (j+1) x
       in left ++ [elemAtJ] ++ middle ++ [elemAtI] ++ right
---------------------------------------------------------------------------------
---                             Тест-кейсы:                                    --
---------------------------------------------------------------------------------
--- we count indices from 0; Test case 2 count as Err?                         --
-- swapAt 1 3 [1,2,3,4,5]          --           [1,4,3,2,5]          --   OK   --
-- swapAt 0 4 [1,2,3,4,5]          --           [5,2,3,4,1]          --   OK   --
-- swapAt 1 6 [1,2,3,4,5]          --           index too large      --   ERR  --
---------------------------------------------------------------------------------
--- №18. Определите предикат, проверяющий, является ли аргумент одноуровневым  --
--- списком.                                                                   --
---------------------------------------------------------------------------------
--- seems impossible ;(
---------------------------------------------------------------------------------
--- №22. Определите функцию, которая обращает список (а b с) и разбивает его   --
--- на уровни (((с) b) а).                                                     --
---------------------------------------------------------------------------------
--- [[[3],2],1] is impossible to construct... at list i've written a reverse 
--- function
reverse' :: [Int] -> [Int]
reverse' [] = []
reverse' x = reverse' (tail x) ++ [head x]
---------------------------------------------------------------------------------
---                             Тест-кейсы:                                    --
---------------------------------------------------------------------------------
-- reverse' [1,2,3,4,5]            --           [5,4,3,2,1]          --   OK   --
-- reverse' []                     --           []                   --   OK   --
---------------------------------------------------------------------------------
--- №26. Определите функцию, разбивающую список (a b с d...) на пары ((а b) (с --
--- d)...).                                                                    --
---------------------------------------------------------------------------------
---its kind of ugly...
makeTuples :: [Int] -> [[Int]]
makeTuples [] = [[]]
makeTuples x = if (length x > 2) then [[head x, head (tail x)]] ++ makeTuples (tail (tail x))
  else if (length x == 2) then [[head x, head (tail x)]] 
    else [[head x]]
---------------------------------------------------------------------------------
---                             Тест-кейсы:                                    --
---------------------------------------------------------------------------------
-- makeTuples []                   --           [[]]                 --   OK   --
-- makeTuples [1]                  --           [[1]]                --   OK   --
-- makeTuples [1,2]                --           [[1,2]]              --   OK   --
-- makeTuples [1,2,3]              --           [[1,2],[3]]          --   OK   --
-- makeTuples [1,2,3,4]            --           [[1,2],[3,4]]        --   OK   --
-- makeTuples [1,2,3,4,5]          --           [[1,2],[3,4],[5]]    --   OK   --
---------------------------------------------------------------------------------
--- №27. Определите функцию, которая, чередуя элементы списков (a b...) и      --
--- (1 2...), образует новый список (a 1 b 2 ...).                             --
---------------------------------------------------------------------------------
makeTuples' :: [Char] -> [Char] -> [Char]
makeTuples' [] [] = []
makeTuples' [] y = y
makeTuples' x [] = x
makeTuples' x y = [head x] ++ [head y] ++ makeTuples' (tail x) (tail y)
---------------------------------------------------------------------------------
---                             Тест-кейсы:                                    --
---------------------------------------------------------------------------------
-- makeTuples ['1','2'] ['A','B']  --           "1A2B"               --   OK   --
-- makeTuples ['1','2'] []         --           "12"                 --   OK   --
-- makeTuples [] ['A','B']         --           "AB"                 --   OK   --
---------------------------------------------------------------------------------